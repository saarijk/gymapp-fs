/// <reference types="node" />
import { inspect } from 'util';
import type { Knex } from 'knex';
import { type AnyEntity, type ConnectionType, type Dictionary, type EntityData, type EntityName, type EntityProperty, type FlushMode, type GroupOperator, LockMode, type LoggingOptions, type MetadataStorage, type ObjectQuery, PopulateHint, type PopulateOptions, type QBFilterQuery, type QBQueryOrderMap, QueryFlag, type QueryResult, type RequiredEntityData } from '@mikro-orm/core';
import { JoinType, QueryType } from './enums';
import type { AbstractSqlDriver } from '../AbstractSqlDriver';
import { type Alias, QueryBuilderHelper } from './QueryBuilderHelper';
import type { SqlEntityManager } from '../SqlEntityManager';
import type { Field, ICriteriaNodeProcessOptions, JoinOptions } from '../typings';
import type { AbstractSqlPlatform } from '../AbstractSqlPlatform';
export interface ExecuteOptions {
    mapResults?: boolean;
    mergeResults?: boolean;
}
/**
 * SQL query builder with fluent interface.
 *
 * ```ts
 * const qb = orm.em.createQueryBuilder(Publisher);
 * qb.select('*')
 *   .where({
 *     name: 'test 123',
 *     type: PublisherType.GLOBAL,
 *   })
 *   .orderBy({
 *     name: QueryOrder.DESC,
 *     type: QueryOrder.ASC,
 *   })
 *   .limit(2, 1);
 *
 * const publisher = await qb.getSingleResult();
 * ```
 */
export declare class QueryBuilder<T extends object = AnyEntity> {
    #private;
    private readonly metadata;
    private readonly driver;
    private readonly context?;
    private connectionType?;
    private readonly em?;
    private readonly loggerContext?;
    get mainAlias(): Alias<T>;
    get alias(): string;
    get helper(): QueryBuilderHelper;
    /** @internal */
    type?: QueryType;
    /** @internal */
    _fields?: Field<T>[];
    /** @internal */
    _populate: PopulateOptions<T>[];
    /** @internal */
    _populateWhere?: ObjectQuery<T> | PopulateHint | `${PopulateHint}`;
    /** @internal */
    __populateWhere?: ObjectQuery<T> | PopulateHint | `${PopulateHint}`;
    /** @internal */
    _populateMap: Dictionary<string>;
    private aliasCounter;
    private flags;
    private finalized;
    private _joins;
    private _explicitAlias;
    private _schema?;
    private _cond;
    private _data;
    private _orderBy;
    private _groupBy;
    private _having;
    private _returning?;
    private _onConflict?;
    private _limit?;
    private _offset?;
    private _distinctOn?;
    private _joinedProps;
    private _cache?;
    private _indexHint?;
    private _comments;
    private _hintComments;
    private flushMode?;
    private lockMode?;
    private lockTables?;
    private subQueries;
    private _mainAlias?;
    private _aliases;
    private _helper?;
    private readonly platform;
    private readonly knex;
    /**
     * @internal
     */
    constructor(entityName: EntityName<T> | QueryBuilder<T>, metadata: MetadataStorage, driver: AbstractSqlDriver, context?: Knex.Transaction<any, any[]> | undefined, alias?: string, connectionType?: ConnectionType | undefined, em?: SqlEntityManager<AbstractSqlDriver<import("..").AbstractSqlConnection, AbstractSqlPlatform>> | undefined, loggerContext?: LoggingOptions | undefined);
    select(fields: Field<T> | Field<T>[], distinct?: boolean): SelectQueryBuilder<T>;
    addSelect(fields: Field<T> | Field<T>[]): SelectQueryBuilder<T>;
    distinct(): SelectQueryBuilder<T>;
    /** postgres only */
    distinctOn(fields: string | string[]): SelectQueryBuilder<T>;
    insert(data: RequiredEntityData<T> | RequiredEntityData<T>[]): InsertQueryBuilder<T>;
    update(data: EntityData<T>): UpdateQueryBuilder<T>;
    delete(cond?: QBFilterQuery): DeleteQueryBuilder<T>;
    truncate(): TruncateQueryBuilder<T>;
    count(field?: string | string[], distinct?: boolean): CountQueryBuilder<T>;
    join(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, type?: JoinType, path?: string, schema?: string): this;
    innerJoin(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, schema?: string): this;
    innerJoinLateral(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, schema?: string): this;
    leftJoin(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, schema?: string): this;
    leftJoinLateral(field: string | Knex.QueryBuilder | QueryBuilder<any>, alias: string, cond?: QBFilterQuery, schema?: string): this;
    joinAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, type?: JoinType, path?: string, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    leftJoinAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    leftJoinLateralAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    innerJoinAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    innerJoinLateralAndSelect(field: string | [field: string, qb: Knex.QueryBuilder | QueryBuilder<any>], alias: string, cond?: QBFilterQuery, fields?: string[], schema?: string): SelectQueryBuilder<T>;
    protected getFieldsForJoinedLoad(prop: EntityProperty<T>, alias: string, explicitFields?: string[]): Field<T>[];
    withSubQuery(subQuery: Knex.QueryBuilder, alias: string): this;
    where(cond: QBFilterQuery<T>, operator?: keyof typeof GroupOperator): this;
    where(cond: string, params?: any[], operator?: keyof typeof GroupOperator): this;
    andWhere(cond: QBFilterQuery<T>): this;
    andWhere(cond: string, params?: any[]): this;
    orWhere(cond: QBFilterQuery<T>): this;
    orWhere(cond: string, params?: any[]): this;
    orderBy(orderBy: QBQueryOrderMap<T> | QBQueryOrderMap<T>[]): SelectQueryBuilder<T>;
    groupBy(fields: (string | keyof T) | readonly (string | keyof T)[]): SelectQueryBuilder<T>;
    having(cond?: QBFilterQuery | string, params?: any[]): SelectQueryBuilder<T>;
    onConflict(fields?: Field<T> | Field<T>[]): InsertQueryBuilder<T>;
    ignore(): this;
    merge(data?: EntityData<T> | Field<T>[]): this;
    returning(fields?: Field<T> | Field<T>[]): this;
    /**
     * @internal
     */
    populate(populate: PopulateOptions<T>[], populateWhere?: ObjectQuery<T> | PopulateHint | `${PopulateHint}`): this;
    limit(limit?: number, offset?: number): SelectQueryBuilder<T>;
    offset(offset?: number): SelectQueryBuilder<T>;
    withSchema(schema?: string): this;
    setLockMode(mode?: LockMode, tables?: string[]): this;
    setFlushMode(flushMode?: FlushMode): this;
    setFlag(flag: QueryFlag): this;
    unsetFlag(flag: QueryFlag): this;
    hasFlag(flag: QueryFlag): boolean;
    cache(config?: boolean | number | [string, number]): this;
    /**
     * Adds index hint to the FROM clause.
     */
    indexHint(sql: string): this;
    /**
     * Prepend comment to the sql query using the syntax `/* ... *&#8205;/`. Some characters are forbidden such as `/*, *&#8205;/` and `?`.
     */
    comment(comment: string | string[]): this;
    /**
     * Add hints to the query using comment-like syntax `/*+ ... *&#8205;/`. MySQL and Oracle use this syntax for optimizer hints.
     * Also various DB proxies and routers use this syntax to pass hints to alter their behavior. In other dialects the hints
     * are ignored as simple comments.
     */
    hintComment(comment: string | string[]): this;
    /**
     * Specifies FROM which entity's table select/update/delete will be executed, removing all previously set FROM-s.
     * Allows setting a main string alias of the selection data.
     */
    from<T extends AnyEntity<T> = AnyEntity>(target: QueryBuilder<T>, aliasName?: string): SelectQueryBuilder<T>;
    from<T extends AnyEntity<T> = AnyEntity>(target: EntityName<T>): SelectQueryBuilder<T>;
    getKnexQuery(processVirtualEntity?: boolean): Knex.QueryBuilder;
    /**
     * Returns the query with parameters as wildcards.
     */
    getQuery(): string;
    toQuery(): {
        sql: string;
        _sql: Knex.Sql;
        params: readonly unknown[];
    };
    /**
     * Returns the list of all parameters for this query.
     */
    getParams(): readonly Knex.Value[];
    /**
     * Returns raw interpolated query string with all the parameters inlined.
     */
    getFormattedQuery(): string;
    /**
     * @internal
     */
    getAliasForJoinPath(path?: string | JoinOptions, options?: ICriteriaNodeProcessOptions): string | undefined;
    /**
     * @internal
     */
    getJoinForPath(path: string, options?: ICriteriaNodeProcessOptions): JoinOptions | undefined;
    /**
     * @internal
     */
    getNextAlias(entityName?: string): string;
    /**
     * @internal
     */
    getAliasMap(): Dictionary<string>;
    /**
     * Executes this QB and returns the raw results, mapped to the property names (unless disabled via last parameter).
     * Use `method` to specify what kind of result you want to get (array/single/meta).
     */
    execute<U = any>(method?: 'all' | 'get' | 'run', options?: ExecuteOptions | boolean): Promise<U>;
    /**
     * Alias for `qb.getResultList()`
     */
    getResult(): Promise<T[]>;
    /**
     * Executes the query, returning array of results
     */
    getResultList(): Promise<T[]>;
    /**
     * Executes the query, returning the first result or null
     */
    getSingleResult(): Promise<T | null>;
    /**
     * Executes count query (without offset and limit), returning total count of results
     */
    getCount(field?: string | string[], distinct?: boolean): Promise<number>;
    /**
     * Executes the query, returning both array of results and total count query (without offset and limit).
     */
    getResultAndCount(): Promise<[T[], number]>;
    /**
     * Provides promise-like interface so we can await the QB instance.
     */
    then<TResult1 = any, TResult2 = never>(onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<T[] | number | QueryResult<T>>;
    /**
     * Returns knex instance with sub-query aliased with given alias.
     * You can provide `EntityName.propName` as alias, then the field name will be used based on the metadata
     */
    as(alias: string): Knex.QueryBuilder;
    clone(reset?: boolean): QueryBuilder<T>;
    getKnex(processVirtualEntity?: boolean): Knex.QueryBuilder;
    private fromVirtual;
    private joinReference;
    private prepareFields;
    private init;
    private getQueryBase;
    private applyDiscriminatorCondition;
    private finalize;
    private processPopulateWhere;
    private hasToManyJoins;
    private wrapPaginateSubQuery;
    private wrapModifySubQuery;
    private getSchema;
    private createAlias;
    private createMainAlias;
    private fromSubQuery;
    private fromEntityName;
    private createQueryBuilderHelper;
    private ensureFromClause;
    private ensureNotFinalized;
    /** @ignore */
    [inspect.custom](depth: number): string;
}
export interface RunQueryBuilder<T extends object> extends Omit<QueryBuilder<T>, 'getResult' | 'getSingleResult' | 'getResultList' | 'where'> {
    where(cond: QBFilterQuery<T> | string, params?: keyof typeof GroupOperator | any[], operator?: keyof typeof GroupOperator): this;
    execute<U = QueryResult<T>>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = QueryResult<T>, TResult2 = never>(onfulfilled?: ((value: QueryResult<T>) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<QueryResult<T>>;
}
export interface SelectQueryBuilder<T extends object> extends QueryBuilder<T> {
    execute<U = T[]>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    execute<U = T[]>(method: 'all', mapResults?: boolean): Promise<U>;
    execute<U = T>(method: 'get', mapResults?: boolean): Promise<U>;
    execute<U = QueryResult<T>>(method: 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = T[], TResult2 = never>(onfulfilled?: ((value: T[]) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<T[]>;
}
export interface CountQueryBuilder<T extends object> extends QueryBuilder<T> {
    execute<U = {
        count: number;
    }[]>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
    execute<U = {
        count: number;
    }[]>(method: 'all', mapResults?: boolean): Promise<U>;
    execute<U = {
        count: number;
    }>(method: 'get', mapResults?: boolean): Promise<U>;
    execute<U = QueryResult<{
        count: number;
    }>>(method: 'run', mapResults?: boolean): Promise<U>;
    then<TResult1 = number, TResult2 = never>(onfulfilled?: ((value: number) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<number>;
}
export interface InsertQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface UpdateQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface DeleteQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
export interface TruncateQueryBuilder<T extends object> extends RunQueryBuilder<T> {
}
